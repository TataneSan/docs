{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bienvenue \u00e0 la SanCorp ! Ici, je vais publier pas mal de tutos, cours ou autre ! N'h\u00e9sitez pas \u00e0 passer r\u00e9guli\u00e8rement","title":"Bienvenue \u00e0 la SanCorp !"},{"location":"#bienvenue-a-la-sancorp","text":"Ici, je vais publier pas mal de tutos, cours ou autre ! N'h\u00e9sitez pas \u00e0 passer r\u00e9guli\u00e8rement","title":"Bienvenue \u00e0 la SanCorp !"},{"location":"Code/Bases/B10%20vers%20binaire/","text":"Base 10 vers binaire Prenons un exemple : 22 = 16 + 4 + 2 = 1 2^4 + 0 2^3 + 1 2^2 + 1 2^1 + 0*2^0 ce qui donne en binaire : 10110 M\u00e9thode \"intuitive\" Une fois qu'on a trouv\u00e9 la premi\u00e8re puissance de 2, on affiche un 1, puis on retire cette puissance \u00e0 notre nombre. On divise ensuite la puissance de 2 par 2. Si le r\u00e9sultat est plus grand que le nombre restant, on affiche un 1, sinon on affiche 0. On recommence ainsi jusqu'\u00e0 arriver \u00e0 une puissance de 2 \u00e9gale \u00e0 0. Pour s'assurer d'afficher au moins un chiffre, m\u00eame si le nombre initial vaut 0, on doit \u00e9viter d'avoir une puissance de 2 \u00e9gale \u00e0 0 d\u00e8s le d\u00e9part. On peut le faire en initialisant notre puissance \u00e0 2, et non \u00e0 1 comme dans l'exercice pr\u00e9c\u00e9dent. M\u00e9thode \"math\u00e9matique\" Reprenons l'exemple : 22 = 16 + 4 + 2 = 1 2^4 + 0 2^3 + 1 2^2 + 1 2^1 + 0 2^0 = 2 (1 2^3 + 0 2^2 + 1 2^1 + 1 2^0) + 0 2^0 = 2 11 + 0 Le chiffre des unit\u00e9s de la d\u00e9composition binaire de 22 est le reste de la division euclidienne de 22 par 2 et les autres chiffres sont ceux de l'\u00e9criture binaire de 11, le quotient de la division euclidienne. On obtient ainsi naturellement un algorithme r\u00e9cursif (un chapitre entier est consacr\u00e9 \u00e0 la r\u00e9cursivit\u00e9 donc nous ne donnerons pas tous les d\u00e9tails) : Fonction afficherBinaire(nombre) Si nombre <=1 alors Afficher(nombre) sinon afficherBinaire(nombre / 2) Afficher(nombre modulo 2) On peut alors remarquer que si nombre <= 1 alors nombre et nombre modulo 2 sont \u00e9gaux. Donc on peut \u00e9crire : Fonction afficherBinaire(nombre) Si nombre <= 1 alors Afficher(nombre modulo 2) sinon afficherBinaire(nombre / 2) Afficher(nombre modulo 2) qui se simplifie en : Fonction afficherBinaire(nombre) Si nombre > 1 alors afficherBinaire(nombre / 2) Afficher(nombre modulo 2) que l'on peut aussi \u00e9crire de fa\u00e7on it\u00e9rative en dressant dans un tableau la liste des chiffres \u00e0 afficher : MAX_CHIFFRES <- 32 chiffresBinaires <- tableau de taille MAX_CHIFFRES nombre <- lireEntier() iChiffre <- 0 Tant que (iChiffre = 0) ou (nombre > 0) faire chiffresBinaires[iChiffre] <- nombre modulo 2 nombre <- nombre / 2 iChiffre <- iChiffre + 1 Tant que iChiffre > 0 iChiffre <- iChiffre - 1 Afficher(chiffresBinaires[iChiffre]) Le programme : En python : nombre = int ( input ()) puissanceDe2 = 2 while puissanceDe2 <= nombre : puissanceDe2 = puissanceDe2 * 2 puissanceDe2 = puissanceDe2 // 2 while puissanceDe2 > 0 : if puissanceDe2 <= nombre : print ( \"1\" , end = \"\" ) nombre = nombre - puissanceDe2 else : print ( \"0\" , end = \"\" ) puissanceDe2 = puissanceDe2 // 2 print ( \"\" ) En r\u00e9cursif : def afficherBinaire ( nombre ): if nombre > 1 : afficherBinaire ( nombre // 2 ) print ( nombre % 2 , end = \"\" ) nombre = int ( input ()) afficherBinaire ( nombre ) Avec un programme it\u00e9ratif MAX_CHIFFRES = 32 nombre = int ( input ()) chiffresBinaires = [ 0 ] * MAX_CHIFFRES iChiffre = 0 while ( iChiffre == 0 ) or ( nombre > 0 ): chiffresBinaires [ iChiffre ] = nombre % 2 nombre = nombre // 2 iChiffre = iChiffre + 1 while iChiffre > 0 : iChiffre = iChiffre - 1 print ( chiffresBinaires [ iChiffre ], end = \"\" ) print () En Java : import algorea.Scanner ; class Main { public static void main ( String [] args ) { Scanner entr\u00e9e = new Scanner ( System . in ); int nombre = entr\u00e9e . nextInt (); int puissanceDe2 = 2 ; while ( puissanceDe2 <= nombre ) puissanceDe2 = puissanceDe2 * 2 ; puissanceDe2 = puissanceDe2 / 2 ; while ( puissanceDe2 > 0 ) { if ( puissanceDe2 <= nombre ) { System . out . print ( \"1\" ); nombre = nombre - puissanceDe2 ; } else System . out . print ( \"0\" ); puissanceDe2 = puissanceDe2 / 2 ; } } }","title":"Base 10 vers binaire"},{"location":"Code/Bases/B10%20vers%20binaire/#base-10-vers-binaire","text":"Prenons un exemple : 22 = 16 + 4 + 2 = 1 2^4 + 0 2^3 + 1 2^2 + 1 2^1 + 0*2^0 ce qui donne en binaire : 10110 M\u00e9thode \"intuitive\" Une fois qu'on a trouv\u00e9 la premi\u00e8re puissance de 2, on affiche un 1, puis on retire cette puissance \u00e0 notre nombre. On divise ensuite la puissance de 2 par 2. Si le r\u00e9sultat est plus grand que le nombre restant, on affiche un 1, sinon on affiche 0. On recommence ainsi jusqu'\u00e0 arriver \u00e0 une puissance de 2 \u00e9gale \u00e0 0. Pour s'assurer d'afficher au moins un chiffre, m\u00eame si le nombre initial vaut 0, on doit \u00e9viter d'avoir une puissance de 2 \u00e9gale \u00e0 0 d\u00e8s le d\u00e9part. On peut le faire en initialisant notre puissance \u00e0 2, et non \u00e0 1 comme dans l'exercice pr\u00e9c\u00e9dent. M\u00e9thode \"math\u00e9matique\" Reprenons l'exemple : 22 = 16 + 4 + 2 = 1 2^4 + 0 2^3 + 1 2^2 + 1 2^1 + 0 2^0 = 2 (1 2^3 + 0 2^2 + 1 2^1 + 1 2^0) + 0 2^0 = 2 11 + 0 Le chiffre des unit\u00e9s de la d\u00e9composition binaire de 22 est le reste de la division euclidienne de 22 par 2 et les autres chiffres sont ceux de l'\u00e9criture binaire de 11, le quotient de la division euclidienne. On obtient ainsi naturellement un algorithme r\u00e9cursif (un chapitre entier est consacr\u00e9 \u00e0 la r\u00e9cursivit\u00e9 donc nous ne donnerons pas tous les d\u00e9tails) : Fonction afficherBinaire(nombre) Si nombre <=1 alors Afficher(nombre) sinon afficherBinaire(nombre / 2) Afficher(nombre modulo 2) On peut alors remarquer que si nombre <= 1 alors nombre et nombre modulo 2 sont \u00e9gaux. Donc on peut \u00e9crire : Fonction afficherBinaire(nombre) Si nombre <= 1 alors Afficher(nombre modulo 2) sinon afficherBinaire(nombre / 2) Afficher(nombre modulo 2) qui se simplifie en : Fonction afficherBinaire(nombre) Si nombre > 1 alors afficherBinaire(nombre / 2) Afficher(nombre modulo 2) que l'on peut aussi \u00e9crire de fa\u00e7on it\u00e9rative en dressant dans un tableau la liste des chiffres \u00e0 afficher : MAX_CHIFFRES <- 32 chiffresBinaires <- tableau de taille MAX_CHIFFRES nombre <- lireEntier() iChiffre <- 0 Tant que (iChiffre = 0) ou (nombre > 0) faire chiffresBinaires[iChiffre] <- nombre modulo 2 nombre <- nombre / 2 iChiffre <- iChiffre + 1 Tant que iChiffre > 0 iChiffre <- iChiffre - 1 Afficher(chiffresBinaires[iChiffre])","title":"Base 10 vers binaire"},{"location":"Code/Bases/B10%20vers%20binaire/#le-programme","text":"","title":"Le programme :"},{"location":"Code/Bases/B10%20vers%20binaire/#en-python","text":"nombre = int ( input ()) puissanceDe2 = 2 while puissanceDe2 <= nombre : puissanceDe2 = puissanceDe2 * 2 puissanceDe2 = puissanceDe2 // 2 while puissanceDe2 > 0 : if puissanceDe2 <= nombre : print ( \"1\" , end = \"\" ) nombre = nombre - puissanceDe2 else : print ( \"0\" , end = \"\" ) puissanceDe2 = puissanceDe2 // 2 print ( \"\" )","title":"En python :"},{"location":"Code/Bases/B10%20vers%20binaire/#en-recursif","text":"def afficherBinaire ( nombre ): if nombre > 1 : afficherBinaire ( nombre // 2 ) print ( nombre % 2 , end = \"\" ) nombre = int ( input ()) afficherBinaire ( nombre )","title":"En r\u00e9cursif :"},{"location":"Code/Bases/B10%20vers%20binaire/#avec-un-programme-iteratif","text":"MAX_CHIFFRES = 32 nombre = int ( input ()) chiffresBinaires = [ 0 ] * MAX_CHIFFRES iChiffre = 0 while ( iChiffre == 0 ) or ( nombre > 0 ): chiffresBinaires [ iChiffre ] = nombre % 2 nombre = nombre // 2 iChiffre = iChiffre + 1 while iChiffre > 0 : iChiffre = iChiffre - 1 print ( chiffresBinaires [ iChiffre ], end = \"\" ) print ()","title":"Avec un programme it\u00e9ratif"},{"location":"Code/Bases/B10%20vers%20binaire/#en-java","text":"import algorea.Scanner ; class Main { public static void main ( String [] args ) { Scanner entr\u00e9e = new Scanner ( System . in ); int nombre = entr\u00e9e . nextInt (); int puissanceDe2 = 2 ; while ( puissanceDe2 <= nombre ) puissanceDe2 = puissanceDe2 * 2 ; puissanceDe2 = puissanceDe2 / 2 ; while ( puissanceDe2 > 0 ) { if ( puissanceDe2 <= nombre ) { System . out . print ( \"1\" ); nombre = nombre - puissanceDe2 ; } else System . out . print ( \"0\" ); puissanceDe2 = puissanceDe2 / 2 ; } } }","title":"En Java :"},{"location":"Code/Bases/Binaire%20vers%20B10/","text":"Binaire vers base 10 Si l'on multiplie chaque chiffre par 2 autant de fois qu'il y a de chiffres qui le suivent, on obtiendra la valeur de la puissance de 2 qui correspond \u00e0 sa position. On peut donc tout simplement lire les chiffres dans l'ordre, les ajouter \u00e0 un total, et multiplier ce total par 2 \u00e0 chaque fois que l'on passe au chiffre suivant. On obtient alors la somme des chiffres multipli\u00e9s par la puissance de 2 correspondant \u00e0 leur position, donc la valeur de l'entier en base 2. Le programme En python : nombreBinaire = input () nombreD\u00e9cimal = 0 for chiffre in nombreBinaire : nombreD\u00e9cimal = ( nombreD\u00e9cimal * 2 ) + int ( chiffre ) print ( nombreD\u00e9cimal ) En Java : import algorea.Scanner ; class Main { public static void main ( String [] args ) { Scanner input = new Scanner ( System . in ); String chiffres = input . next (); int nombre = 0 ; for ( int iChiffre = 0 ; iChiffre < chiffres . length (); iChiffre ++ ) nombre = nombre * 2 + chiffres . charAt ( iChiffre ) - '0' ; System . out . println ( nombre ); } } En C : #include <stdio.h> int main () { char caractereLu = '0' ; int total = 0 ; while ( caractereLu != '\\n' ) { scanf ( \"%c\" , & caractereLu ); if ( caractereLu == '1' ) total = total * 2 + 1 ; else if ( caractereLu == '0' ) total *= 2 ; } printf ( \"%d \\n \" , total ); return 0 ; }","title":"Binaire vers base 10"},{"location":"Code/Bases/Binaire%20vers%20B10/#binaire-vers-base-10","text":"Si l'on multiplie chaque chiffre par 2 autant de fois qu'il y a de chiffres qui le suivent, on obtiendra la valeur de la puissance de 2 qui correspond \u00e0 sa position. On peut donc tout simplement lire les chiffres dans l'ordre, les ajouter \u00e0 un total, et multiplier ce total par 2 \u00e0 chaque fois que l'on passe au chiffre suivant. On obtient alors la somme des chiffres multipli\u00e9s par la puissance de 2 correspondant \u00e0 leur position, donc la valeur de l'entier en base 2.","title":"Binaire vers base 10"},{"location":"Code/Bases/Binaire%20vers%20B10/#le-programme","text":"","title":"Le programme"},{"location":"Code/Bases/Binaire%20vers%20B10/#en-python","text":"nombreBinaire = input () nombreD\u00e9cimal = 0 for chiffre in nombreBinaire : nombreD\u00e9cimal = ( nombreD\u00e9cimal * 2 ) + int ( chiffre ) print ( nombreD\u00e9cimal )","title":"En python :"},{"location":"Code/Bases/Binaire%20vers%20B10/#en-java","text":"import algorea.Scanner ; class Main { public static void main ( String [] args ) { Scanner input = new Scanner ( System . in ); String chiffres = input . next (); int nombre = 0 ; for ( int iChiffre = 0 ; iChiffre < chiffres . length (); iChiffre ++ ) nombre = nombre * 2 + chiffres . charAt ( iChiffre ) - '0' ; System . out . println ( nombre ); } }","title":"En Java :"},{"location":"Code/Bases/Binaire%20vers%20B10/#en-c","text":"#include <stdio.h> int main () { char caractereLu = '0' ; int total = 0 ; while ( caractereLu != '\\n' ) { scanf ( \"%c\" , & caractereLu ); if ( caractereLu == '1' ) total = total * 2 + 1 ; else if ( caractereLu == '0' ) total *= 2 ; } printf ( \"%d \\n \" , total ); return 0 ; }","title":"En C :"},{"location":"Code/Bases/Moyenne%20hexa/","text":"Moyenne hexad\u00e9cimale On cr\u00e9e une fonction qui lit un nombre hexad\u00e9cimal tap\u00e9 au clavier et retourne sa valeur, puis une fonction qui affiche en hexad\u00e9cimal une valeur pass\u00e9e en param\u00e8tre. Le programme peut alors s'\u00e9crire simplement. Le programme : CHIFFRES <- \"0123456789ABCDEF\" Fonction lireEntier() nombre <- 0 Pour chaque chiffre lu faire nombre <- nombre * 16 Si (chiffre >= '0') et (chiffre <= '9') alors nombre <- nombre + entier(chiffre) sinon nombre <- nombre + codeASCII(chiffre) - codeASCII('A') + 10 Retourner nombre Fonction afficherEntier(nombre) Si nombre > 15 alors afficherEntier(nombre / 16) Afficher(CHIFFRES[nombre modulo 16]) nbNombres <- lireEntier() somme <- 0 R\u00e9p\u00e9ter nbNombres fois somme <- somme + lireEntier() afficherEntier(somme / nbNombres) En python : CHIFFRES = \"0123456789ABCDEF\" def lireEntier (): nombre = 0 for chiffre in input (): nombre = nombre * 16 if ( chiffre >= '0' ) and ( chiffre <= '9' ): nombre += int ( chiffre ) else : nombre += ord ( chiffre ) - ord ( 'A' ) + 10 return nombre def afficherEntier ( nombre ): if nombre > 15 : afficherEntier ( nombre // 16 ) print ( CHIFFRES [ nombre % 16 ], end = \"\" ) nbNombres = lireEntier () somme = 0 for loop in range ( nbNombres ): somme += lireEntier () afficherEntier ( somme // nbNombres ) En Java : import algorea.Scanner ; class Main { static final String CHIFFRES = \"0123456789ABCDEF\" ; static Scanner input = new Scanner ( System . in ); public static void main ( String [] args ) { int nbNombres = lireEntier (); int somme = 0 ; for ( int nombre = 0 ; nombre < nbNombres ; nombre ++ ) somme += lireEntier (); afficherEntier ( somme / nbNombres ); } static void afficherEntier ( int nombre ) { if ( nombre > 15 ) afficherEntier ( nombre / 16 ); System . out . print ( CHIFFRES . charAt ( nombre % 16 )); } static int lireEntier () { char [] chiffres = input . next (). toCharArray (); int nombre = 0 ; for ( char chiffre : chiffres ) if ( Character . isDigit ( chiffre )) nombre = nombre * 16 + chiffre - '0' ; else nombre = nombre * 16 + chiffre - 'A' + 10 ; return nombre ; } } En C : #include <stdio.h> int litNombreHexa () { char caractereLu = '0' ; int total = 0 ; while ( caractereLu != '\\n' ) { scanf ( \"%c\" , & caractereLu ); if (( caractereLu >= '0' ) && ( caractereLu <= '9' )) total = total * 16 + ( int )( caractereLu - '0' ); else if (( caractereLu >= 'A' ) && ( caractereLu <= 'F' )) total = total * 16 + 10 + ( int )( caractereLu - 'A' ); } return total ; } void afficheNombreHexa ( int nombre ) { int puissanceDe16 = 16 ; while ( puissanceDe16 <= nombre ) puissanceDe16 *= 16 ; puissanceDe16 /= 16 ; while ( puissanceDe16 > 0 ) { int chiffre = ( nombre / puissanceDe16 ) % 16 ; if ( chiffre < 10 ) printf ( \"%c\" , chiffre + '0' ); else printf ( \"%c\" , chiffre - 10 + 'A' ); puissanceDe16 /= 16 ; } printf ( \" \\n \" ); } int main () { int nbValeurs ; int valeursLues = 0 ; int total = 0 ; nbValeurs = litNombreHexa (); while ( valeursLues < nbValeurs ) { total += litNombreHexa (); valeursLues ++ ; } afficheNombreHexa ( total / nbValeurs ); return 0 ; }","title":"Moyenne hexad\u00e9cimale"},{"location":"Code/Bases/Moyenne%20hexa/#moyenne-hexadecimale","text":"On cr\u00e9e une fonction qui lit un nombre hexad\u00e9cimal tap\u00e9 au clavier et retourne sa valeur, puis une fonction qui affiche en hexad\u00e9cimal une valeur pass\u00e9e en param\u00e8tre. Le programme peut alors s'\u00e9crire simplement.","title":"Moyenne hexad\u00e9cimale"},{"location":"Code/Bases/Moyenne%20hexa/#le-programme","text":"CHIFFRES <- \"0123456789ABCDEF\" Fonction lireEntier() nombre <- 0 Pour chaque chiffre lu faire nombre <- nombre * 16 Si (chiffre >= '0') et (chiffre <= '9') alors nombre <- nombre + entier(chiffre) sinon nombre <- nombre + codeASCII(chiffre) - codeASCII('A') + 10 Retourner nombre Fonction afficherEntier(nombre) Si nombre > 15 alors afficherEntier(nombre / 16) Afficher(CHIFFRES[nombre modulo 16]) nbNombres <- lireEntier() somme <- 0 R\u00e9p\u00e9ter nbNombres fois somme <- somme + lireEntier() afficherEntier(somme / nbNombres)","title":"Le programme :"},{"location":"Code/Bases/Moyenne%20hexa/#en-python","text":"CHIFFRES = \"0123456789ABCDEF\" def lireEntier (): nombre = 0 for chiffre in input (): nombre = nombre * 16 if ( chiffre >= '0' ) and ( chiffre <= '9' ): nombre += int ( chiffre ) else : nombre += ord ( chiffre ) - ord ( 'A' ) + 10 return nombre def afficherEntier ( nombre ): if nombre > 15 : afficherEntier ( nombre // 16 ) print ( CHIFFRES [ nombre % 16 ], end = \"\" ) nbNombres = lireEntier () somme = 0 for loop in range ( nbNombres ): somme += lireEntier () afficherEntier ( somme // nbNombres )","title":"En python :"},{"location":"Code/Bases/Moyenne%20hexa/#en-java","text":"import algorea.Scanner ; class Main { static final String CHIFFRES = \"0123456789ABCDEF\" ; static Scanner input = new Scanner ( System . in ); public static void main ( String [] args ) { int nbNombres = lireEntier (); int somme = 0 ; for ( int nombre = 0 ; nombre < nbNombres ; nombre ++ ) somme += lireEntier (); afficherEntier ( somme / nbNombres ); } static void afficherEntier ( int nombre ) { if ( nombre > 15 ) afficherEntier ( nombre / 16 ); System . out . print ( CHIFFRES . charAt ( nombre % 16 )); } static int lireEntier () { char [] chiffres = input . next (). toCharArray (); int nombre = 0 ; for ( char chiffre : chiffres ) if ( Character . isDigit ( chiffre )) nombre = nombre * 16 + chiffre - '0' ; else nombre = nombre * 16 + chiffre - 'A' + 10 ; return nombre ; } }","title":"En Java :"},{"location":"Code/Bases/Moyenne%20hexa/#en-c","text":"#include <stdio.h> int litNombreHexa () { char caractereLu = '0' ; int total = 0 ; while ( caractereLu != '\\n' ) { scanf ( \"%c\" , & caractereLu ); if (( caractereLu >= '0' ) && ( caractereLu <= '9' )) total = total * 16 + ( int )( caractereLu - '0' ); else if (( caractereLu >= 'A' ) && ( caractereLu <= 'F' )) total = total * 16 + 10 + ( int )( caractereLu - 'A' ); } return total ; } void afficheNombreHexa ( int nombre ) { int puissanceDe16 = 16 ; while ( puissanceDe16 <= nombre ) puissanceDe16 *= 16 ; puissanceDe16 /= 16 ; while ( puissanceDe16 > 0 ) { int chiffre = ( nombre / puissanceDe16 ) % 16 ; if ( chiffre < 10 ) printf ( \"%c\" , chiffre + '0' ); else printf ( \"%c\" , chiffre - 10 + 'A' ); puissanceDe16 /= 16 ; } printf ( \" \\n \" ); } int main () { int nbValeurs ; int valeursLues = 0 ; int total = 0 ; nbValeurs = litNombreHexa (); while ( valeursLues < nbValeurs ) { total += litNombreHexa (); valeursLues ++ ; } afficheNombreHexa ( total / nbValeurs ); return 0 ; }","title":"En C :"},{"location":"Code/Bases/Tables%20de%20multiplications%20binaire/","text":"Tables de multiplications binaire On \u00e9crit une fonction qui se charge d'afficher un nombre en binaire. On peut ensuite l'appeler dans deux boucles imbriqu\u00e9es qui parcourent la table. Le programme nbLignes <- LireEntier() Fonction afficherBinaire(nombre) Si nombre > 1 alors afficherBinaire(nombre / 2) Afficher(nombre modulo 2) Pour ligne dans [0; nbLignes[ faire Pour colonne dans [0; nbLignes[ faire AfficherBinaire(ligne * colonne) Afficher(\"\\t\") Afficher(\"\\n\") En python : def afficherBinaire ( nombre ): if nombre > 1 : afficherBinaire ( nombre // 2 ) print ( nombre % 2 , end = \"\" ) nbColonnes = int ( input ()) for ligne in range ( 1 , nbColonnes + 1 ): for colonne in range ( 1 , nbColonnes + 1 ): afficherBinaire ( ligne * colonne ) print ( \" \\t \" , end = \"\" ) print () En C : #include <stdio.h> void afficheBinaire ( int nombre ) { int puissanceDe2 = 2 ; while ( puissanceDe2 <= nombre ) puissanceDe2 *= 2 ; while ( puissanceDe2 > 1 ) { if ( nombre % puissanceDe2 >= puissanceDe2 / 2 ) printf ( \"1\" ); else printf ( \"0\" ); puissanceDe2 /= 2 ; } } int main () { int nbLignes ; int ligneActuelle = 1 ; scanf ( \"%d\" , & nbLignes ); while ( ligneActuelle <= nbLignes ) { int colonneActuelle = 1 ; while ( colonneActuelle <= nbLignes ) { afficheBinaire ( colonneActuelle * ligneActuelle ); if ( colonneActuelle != nbLignes ) printf ( \" \\t \" ); colonneActuelle ++ ; } printf ( \" \\n \" ); ligneActuelle ++ ; } return 0 ; } En Java : import algorea.Scanner ; class Main { public static void main ( String [] args ) { Scanner entr\u00e9e = new Scanner ( System . in ); int nbColonnes = entr\u00e9e . nextInt (); for ( int ligne = 1 ; ligne <= nbColonnes ; ligne ++ ) { for ( int colonne = 1 ; colonne <= nbColonnes ; colonne ++ ) { afficherBinaire ( ligne * colonne ); System . out . print ( \"\\t\" ); } System . out . println (); } } static void afficherBinaire ( int nombre ) { if ( nombre > 1 ) afficherBinaire ( nombre / 2 ); System . out . print ( nombre % 2 ); } }","title":"Tables de multiplications binaire"},{"location":"Code/Bases/Tables%20de%20multiplications%20binaire/#tables-de-multiplications-binaire","text":"On \u00e9crit une fonction qui se charge d'afficher un nombre en binaire. On peut ensuite l'appeler dans deux boucles imbriqu\u00e9es qui parcourent la table.","title":"Tables de multiplications binaire"},{"location":"Code/Bases/Tables%20de%20multiplications%20binaire/#le-programme","text":"nbLignes <- LireEntier() Fonction afficherBinaire(nombre) Si nombre > 1 alors afficherBinaire(nombre / 2) Afficher(nombre modulo 2) Pour ligne dans [0; nbLignes[ faire Pour colonne dans [0; nbLignes[ faire AfficherBinaire(ligne * colonne) Afficher(\"\\t\") Afficher(\"\\n\")","title":"Le programme"},{"location":"Code/Bases/Tables%20de%20multiplications%20binaire/#en-python","text":"def afficherBinaire ( nombre ): if nombre > 1 : afficherBinaire ( nombre // 2 ) print ( nombre % 2 , end = \"\" ) nbColonnes = int ( input ()) for ligne in range ( 1 , nbColonnes + 1 ): for colonne in range ( 1 , nbColonnes + 1 ): afficherBinaire ( ligne * colonne ) print ( \" \\t \" , end = \"\" ) print ()","title":"En python :"},{"location":"Code/Bases/Tables%20de%20multiplications%20binaire/#en-c","text":"#include <stdio.h> void afficheBinaire ( int nombre ) { int puissanceDe2 = 2 ; while ( puissanceDe2 <= nombre ) puissanceDe2 *= 2 ; while ( puissanceDe2 > 1 ) { if ( nombre % puissanceDe2 >= puissanceDe2 / 2 ) printf ( \"1\" ); else printf ( \"0\" ); puissanceDe2 /= 2 ; } } int main () { int nbLignes ; int ligneActuelle = 1 ; scanf ( \"%d\" , & nbLignes ); while ( ligneActuelle <= nbLignes ) { int colonneActuelle = 1 ; while ( colonneActuelle <= nbLignes ) { afficheBinaire ( colonneActuelle * ligneActuelle ); if ( colonneActuelle != nbLignes ) printf ( \" \\t \" ); colonneActuelle ++ ; } printf ( \" \\n \" ); ligneActuelle ++ ; } return 0 ; }","title":"En C :"},{"location":"Code/Bases/Tables%20de%20multiplications%20binaire/#en-java","text":"import algorea.Scanner ; class Main { public static void main ( String [] args ) { Scanner entr\u00e9e = new Scanner ( System . in ); int nbColonnes = entr\u00e9e . nextInt (); for ( int ligne = 1 ; ligne <= nbColonnes ; ligne ++ ) { for ( int colonne = 1 ; colonne <= nbColonnes ; colonne ++ ) { afficherBinaire ( ligne * colonne ); System . out . print ( \"\\t\" ); } System . out . println (); } } static void afficherBinaire ( int nombre ) { if ( nombre > 1 ) afficherBinaire ( nombre / 2 ); System . out . print ( nombre % 2 ); } }","title":"En Java :"},{"location":"Code/Tableaux/Carr%C3%A9%20magique/","text":"Carr\u00e9 magique Algorithme 1 On commence par stocker le carr\u00e9 magique dans un tableau puis on calcule les sommes sur chaque ligne/colonne/diagonales et on v\u00e9rifie qu'elles sont toutes \u00e9gales. On doit \u00e9galement v\u00e9rifier que tous les nombres sont dans le bon intervalle de valeur et qu'ils sont tous pr\u00e9sents. tailleGrille <- LireEntier() nombresCarre <- Tableau 2D de taille tailleGrille * tailleGrille initialis\u00e9 avec des entiers lus Fonction tousNombresPresents() maxVal <- tailleGrille * tailleGrille + 1 presents <- Tableau de taille maxVal initialis\u00e9 \u00e0 Faux Pour chaque ligne dans nombresCarre faire Pour chaque nombre dans ligne faire Si (nombre <= 0) ou (nombre >= maxVal) ou presents[nombre] alors Retourne Faux sinon presents[nombre] <- Vrai Retourne Vrai Fonction totauxCorrects() Fonction totalPourDirection(linDepart, colDepart, deltaLin, deltaCol) lin <- linDepart col <- colDepart total <- 0 R\u00e9p\u00e9ter tailleGrille fois total <- total + nombresCarre[lin][col] lin <- lin + deltaLin col <- col + deltaCol Retourne total total <- totalPourDirection(0, 0, 1, 1) Si (totalPourDirection(0, tailleGrille - 1, 1, -1) != total) alors Retourne Faux Pour position <- 0 \u00e0 (tailleGrille - 1) faire Si totalPourDirection(position, 0, 0, 1) != total alors Retourne Faux Si totalPourDirection(0, position, 1, 0) != total alors Retourne Faux Retourne Vrai Si tousNombresPresents() et totauxCorrects() alors Afficher\u00c0LaLigne(\"yes\") sinon Afficher\u00c0LaLigne(\"no\") En python : def main (): def tousNombresPresents (): nonlocal tailleGrille maxVal = tailleGrille * tailleGrille + 1 presents = [ False ] * maxVal for ligne in nombresCarre : for nombre in ligne : if ( nombre <= 0 ) or ( nombre >= maxVal ) or presents [ nombre ]: return False else : presents [ nombre ] = True return True def totauxCorrects (): nonlocal tailleGrille def totalPourDirection ( linDepart , colDepart , deltaLin , deltaCol ): nonlocal tailleGrille lin , col = linDepart , colDepart total = 0 for loop in range ( tailleGrille ): total += nombresCarre [ lin ][ col ] lin += deltaLin col += deltaCol return total total = totalPourDirection ( 0 , 0 , 1 , 1 ) if ( totalPourDirection ( 0 , tailleGrille - 1 , 1 , - 1 ) != total ): return False for position in range ( tailleGrille ): if totalPourDirection ( position , 0 , 0 , 1 ) != total : return False if totalPourDirection ( 0 , position , 1 , 0 ) != total : return False return True tailleGrille = int ( input ()) nombresCarre = [ list ( map ( int , input () . split () )) for loop in range ( tailleGrille )] if tousNombresPresents () and totauxCorrects (): print ( \"yes\" ) else : print ( \"no\" ) main () En Java : import algorea.Scanner ; class Main { static int [][] nombresCarr\u00e9 ; static int tailleGrille ; public static void main ( String [] args ) { Scanner entr\u00e9e = new Scanner ( System . in ); tailleGrille = entr\u00e9e . nextInt (); nombresCarr\u00e9 = new int [ tailleGrille ][ tailleGrille ] ; for ( int ligne = 0 ; ligne < tailleGrille ; ligne ++ ) for ( int colonne = 0 ; colonne < tailleGrille ; colonne ++ ) nombresCarr\u00e9 [ ligne ][ colonne ] = entr\u00e9e . nextInt (); if ( tousNombresPr\u00e9sents () && totauxCorrects ()) System . out . println ( \"yes\" ); else System . out . println ( \"no\" ); } static int totalPourDirection ( int linDepart , int colDepart , int deltaLin , int deltaCol ) { int lin = linDepart , col = colDepart , total = 0 ; for ( int position = 0 ; position < tailleGrille ; position ++ ) { total += nombresCarr\u00e9 [ lin ][ col ] ; lin += deltaLin ; col += deltaCol ; } return total ; } static boolean totauxCorrects () { int total = totalPourDirection ( 0 , 0 , 1 , 1 ); if ( totalPourDirection ( 0 , tailleGrille - 1 , 1 , - 1 ) != total ) return false ; for ( int ligne = 0 ; ligne < tailleGrille ; ligne ++ ) if ( totalPourDirection ( ligne , 0 , 0 , 1 ) != total ) return false ; for ( int colonne = 0 ; colonne < tailleGrille ; colonne ++ ) if ( totalPourDirection ( 0 , colonne , 1 , 0 ) != total ) return false ; return true ; } static boolean tousNombresPr\u00e9sents () { int maxVal = tailleGrille * tailleGrille + 1 ; boolean [] pr\u00e9sents = new boolean [ maxVal ] ; for ( int nombre = 0 ; nombre < maxVal ; nombre ++ ) pr\u00e9sents [ nombre ] = false ; for ( int ligne = 0 ; ligne < tailleGrille ; ligne ++ ) for ( int colonne = 0 ; colonne < tailleGrille ; colonne ++ ) { int nombre = nombresCarr\u00e9 [ ligne ][ colonne ] ; if (( nombre <= 0 ) || ( nombre >= maxVal ) || pr\u00e9sents [ nombre ] ) return false ; pr\u00e9sents [ nombre ] = true ; } return true ; } } ``` c # include < stdio . h > # include < stdbool . h > # define MAX_TAILLE 20 int nombresCarre [ MAX_TAILLE ][ MAX_TAILLE ] ; int tailleGrille ; int totalPourDirection ( int linDepart , int colDepart , int deltaLin , int deltaCol ) { int lin = linDepart , col = colDepart , total = 0 ; for ( int position = 0 ; position < tailleGrille ; position ++ ) { total += nombresCarre [ lin ][ col ] ; lin += deltaLin ; col += deltaCol ; } return total ; } bool totauxCorrects () { int total = totalPourDirection ( 0 , 0 , 1 , 1 ); if ( totalPourDirection ( 0 , tailleGrille - 1 , 1 , - 1 ) != total ) return false ; for ( int ligne = 0 ; ligne < tailleGrille ; ligne ++ ) if ( totalPourDirection ( ligne , 0 , 0 , 1 ) != total ) return false ; for ( int colonne = 0 ; colonne < tailleGrille ; colonne ++ ) if ( totalPourDirection ( 0 , colonne , 1 , 0 ) != total ) return false ; return true ; } bool tousNombresPresents () { int maxVal = tailleGrille * tailleGrille + 1 ; int nombrePresent [ maxVal ] ; for ( int nombre = 0 ; nombre < maxVal ; nombre ++ ) nombrePresent [ nombre ] = 0 ; for ( int ligne = 0 ; ligne < tailleGrille ; ligne ++ ) for ( int colonne = 0 ; colonne < tailleGrille ; colonne ++ ) { int valeurCase = nombresCarre [ ligne ][ colonne ] ; if (( valeurCase <= 0 ) || ( valeurCase >= maxVal )) return 0 ; if ( nombrePresent [ valeurCase ] != 0 ) return 0 ; nombrePresent [ valeurCase ]++ ; } return 1 ; } int main () { scanf ( \"%d\" , & tailleGrille ); for ( int ligne = 0 ; ligne < tailleGrille ; ligne ++ ) for ( int colonne = 0 ; colonne < tailleGrille ; colonne ++ ) scanf ( \"%d\" , & ( nombresCarre [ ligne ][ colonne ] )); if ( tousNombresPresents () && totauxCorrects ()) printf ( \"yes\\n\" ); else printf ( \"no\\n\" ); return 0 ; } Algorithme 2 Dans cette variante on ne stocke pas le carr\u00e9 magique mais on calcule, au fur et \u00e0 mesure de la lecture, les sommes sur chaque ligne/colonne/diagonales, tout en v\u00e9rifiant que tous les nombres sont dans le bon intervalle de valeur et qu'ils sont tous pr\u00e9sents. Une fois a lecture finie, il suffit de v\u00e9rifier que toutes les sommes sont \u00e9gales. #include <iostream> using namespace std ; const int MAX_TAILLE = 20 ; int direction [ 2 ][ MAX_TAILLE ]; // lignes + colonnes int diagonales [ 2 ]; int nombres [ MAX_TAILLE * MAX_TAILLE + 1 ]; int tailleGrille ; bool lireGrille () { int val ; for ( int ligne = 0 ; ligne < tailleGrille ; ligne ++ ) for ( int colonne = 0 ; colonne < tailleGrille ; colonne ++ ) { cin >> val ; if ( 1 <= val && val <= tailleGrille * tailleGrille && nombres [ val ] == 0 ) nombres [ val ] = 1 ; else return false ; direction [ 0 ][ ligne ] += val ; direction [ 1 ][ colonne ] += val ; if ( ligne == colonne ) diagonales [ 0 ] += val ; if ( ligne + colonne == tailleGrille - 1 ) diagonales [ 1 ] += val ; } return true ; } bool verifieValeurs () { const int val = diagonales [ 0 ]; for ( int dir = 0 ; dir <= 1 ; dir ++ ) for ( int i = 0 ; i < tailleGrille ; i ++ ) if ( direction [ dir ][ i ] != val ) return false ; return ( diagonales [ 0 ] == val ) && ( diagonales [ 1 ] == val ); } int main () { cin >> tailleGrille ; // Initilisation des tableaux : pas n\u00e9cessaire en pratique for ( int dir = 0 ; dir <= 1 ; dir ++ ) for ( int i = 0 ; i < tailleGrille ; i ++ ) direction [ dir ][ i ] = 0 ; for ( int i = 0 ; i <= 1 ; i ++ ) diagonales [ i ] = 0 ; for ( int i = 1 ; i <= tailleGrille * tailleGrille ; i ++ ) nombres [ i ] = 0 ; if ( lireGrille () && verifieValeurs ()) cout << \"yes\" << endl ; else cout << \"no\" << endl ; }","title":"Carr\u00e9 magique"},{"location":"Code/Tableaux/Carr%C3%A9%20magique/#carre-magique","text":"","title":"Carr\u00e9 magique"},{"location":"Code/Tableaux/Carr%C3%A9%20magique/#algorithme-1","text":"On commence par stocker le carr\u00e9 magique dans un tableau puis on calcule les sommes sur chaque ligne/colonne/diagonales et on v\u00e9rifie qu'elles sont toutes \u00e9gales. On doit \u00e9galement v\u00e9rifier que tous les nombres sont dans le bon intervalle de valeur et qu'ils sont tous pr\u00e9sents. tailleGrille <- LireEntier() nombresCarre <- Tableau 2D de taille tailleGrille * tailleGrille initialis\u00e9 avec des entiers lus Fonction tousNombresPresents() maxVal <- tailleGrille * tailleGrille + 1 presents <- Tableau de taille maxVal initialis\u00e9 \u00e0 Faux Pour chaque ligne dans nombresCarre faire Pour chaque nombre dans ligne faire Si (nombre <= 0) ou (nombre >= maxVal) ou presents[nombre] alors Retourne Faux sinon presents[nombre] <- Vrai Retourne Vrai Fonction totauxCorrects() Fonction totalPourDirection(linDepart, colDepart, deltaLin, deltaCol) lin <- linDepart col <- colDepart total <- 0 R\u00e9p\u00e9ter tailleGrille fois total <- total + nombresCarre[lin][col] lin <- lin + deltaLin col <- col + deltaCol Retourne total total <- totalPourDirection(0, 0, 1, 1) Si (totalPourDirection(0, tailleGrille - 1, 1, -1) != total) alors Retourne Faux Pour position <- 0 \u00e0 (tailleGrille - 1) faire Si totalPourDirection(position, 0, 0, 1) != total alors Retourne Faux Si totalPourDirection(0, position, 1, 0) != total alors Retourne Faux Retourne Vrai Si tousNombresPresents() et totauxCorrects() alors Afficher\u00c0LaLigne(\"yes\") sinon Afficher\u00c0LaLigne(\"no\")","title":"Algorithme 1"},{"location":"Code/Tableaux/Carr%C3%A9%20magique/#en-python","text":"def main (): def tousNombresPresents (): nonlocal tailleGrille maxVal = tailleGrille * tailleGrille + 1 presents = [ False ] * maxVal for ligne in nombresCarre : for nombre in ligne : if ( nombre <= 0 ) or ( nombre >= maxVal ) or presents [ nombre ]: return False else : presents [ nombre ] = True return True def totauxCorrects (): nonlocal tailleGrille def totalPourDirection ( linDepart , colDepart , deltaLin , deltaCol ): nonlocal tailleGrille lin , col = linDepart , colDepart total = 0 for loop in range ( tailleGrille ): total += nombresCarre [ lin ][ col ] lin += deltaLin col += deltaCol return total total = totalPourDirection ( 0 , 0 , 1 , 1 ) if ( totalPourDirection ( 0 , tailleGrille - 1 , 1 , - 1 ) != total ): return False for position in range ( tailleGrille ): if totalPourDirection ( position , 0 , 0 , 1 ) != total : return False if totalPourDirection ( 0 , position , 1 , 0 ) != total : return False return True tailleGrille = int ( input ()) nombresCarre = [ list ( map ( int , input () . split () )) for loop in range ( tailleGrille )] if tousNombresPresents () and totauxCorrects (): print ( \"yes\" ) else : print ( \"no\" ) main ()","title":"En python :"},{"location":"Code/Tableaux/Carr%C3%A9%20magique/#en-java","text":"import algorea.Scanner ; class Main { static int [][] nombresCarr\u00e9 ; static int tailleGrille ; public static void main ( String [] args ) { Scanner entr\u00e9e = new Scanner ( System . in ); tailleGrille = entr\u00e9e . nextInt (); nombresCarr\u00e9 = new int [ tailleGrille ][ tailleGrille ] ; for ( int ligne = 0 ; ligne < tailleGrille ; ligne ++ ) for ( int colonne = 0 ; colonne < tailleGrille ; colonne ++ ) nombresCarr\u00e9 [ ligne ][ colonne ] = entr\u00e9e . nextInt (); if ( tousNombresPr\u00e9sents () && totauxCorrects ()) System . out . println ( \"yes\" ); else System . out . println ( \"no\" ); } static int totalPourDirection ( int linDepart , int colDepart , int deltaLin , int deltaCol ) { int lin = linDepart , col = colDepart , total = 0 ; for ( int position = 0 ; position < tailleGrille ; position ++ ) { total += nombresCarr\u00e9 [ lin ][ col ] ; lin += deltaLin ; col += deltaCol ; } return total ; } static boolean totauxCorrects () { int total = totalPourDirection ( 0 , 0 , 1 , 1 ); if ( totalPourDirection ( 0 , tailleGrille - 1 , 1 , - 1 ) != total ) return false ; for ( int ligne = 0 ; ligne < tailleGrille ; ligne ++ ) if ( totalPourDirection ( ligne , 0 , 0 , 1 ) != total ) return false ; for ( int colonne = 0 ; colonne < tailleGrille ; colonne ++ ) if ( totalPourDirection ( 0 , colonne , 1 , 0 ) != total ) return false ; return true ; } static boolean tousNombresPr\u00e9sents () { int maxVal = tailleGrille * tailleGrille + 1 ; boolean [] pr\u00e9sents = new boolean [ maxVal ] ; for ( int nombre = 0 ; nombre < maxVal ; nombre ++ ) pr\u00e9sents [ nombre ] = false ; for ( int ligne = 0 ; ligne < tailleGrille ; ligne ++ ) for ( int colonne = 0 ; colonne < tailleGrille ; colonne ++ ) { int nombre = nombresCarr\u00e9 [ ligne ][ colonne ] ; if (( nombre <= 0 ) || ( nombre >= maxVal ) || pr\u00e9sents [ nombre ] ) return false ; pr\u00e9sents [ nombre ] = true ; } return true ; } } ``` c # include < stdio . h > # include < stdbool . h > # define MAX_TAILLE 20 int nombresCarre [ MAX_TAILLE ][ MAX_TAILLE ] ; int tailleGrille ; int totalPourDirection ( int linDepart , int colDepart , int deltaLin , int deltaCol ) { int lin = linDepart , col = colDepart , total = 0 ; for ( int position = 0 ; position < tailleGrille ; position ++ ) { total += nombresCarre [ lin ][ col ] ; lin += deltaLin ; col += deltaCol ; } return total ; } bool totauxCorrects () { int total = totalPourDirection ( 0 , 0 , 1 , 1 ); if ( totalPourDirection ( 0 , tailleGrille - 1 , 1 , - 1 ) != total ) return false ; for ( int ligne = 0 ; ligne < tailleGrille ; ligne ++ ) if ( totalPourDirection ( ligne , 0 , 0 , 1 ) != total ) return false ; for ( int colonne = 0 ; colonne < tailleGrille ; colonne ++ ) if ( totalPourDirection ( 0 , colonne , 1 , 0 ) != total ) return false ; return true ; } bool tousNombresPresents () { int maxVal = tailleGrille * tailleGrille + 1 ; int nombrePresent [ maxVal ] ; for ( int nombre = 0 ; nombre < maxVal ; nombre ++ ) nombrePresent [ nombre ] = 0 ; for ( int ligne = 0 ; ligne < tailleGrille ; ligne ++ ) for ( int colonne = 0 ; colonne < tailleGrille ; colonne ++ ) { int valeurCase = nombresCarre [ ligne ][ colonne ] ; if (( valeurCase <= 0 ) || ( valeurCase >= maxVal )) return 0 ; if ( nombrePresent [ valeurCase ] != 0 ) return 0 ; nombrePresent [ valeurCase ]++ ; } return 1 ; } int main () { scanf ( \"%d\" , & tailleGrille ); for ( int ligne = 0 ; ligne < tailleGrille ; ligne ++ ) for ( int colonne = 0 ; colonne < tailleGrille ; colonne ++ ) scanf ( \"%d\" , & ( nombresCarre [ ligne ][ colonne ] )); if ( tousNombresPresents () && totauxCorrects ()) printf ( \"yes\\n\" ); else printf ( \"no\\n\" ); return 0 ; }","title":"En Java :"},{"location":"Code/Tableaux/Carr%C3%A9%20magique/#algorithme-2","text":"Dans cette variante on ne stocke pas le carr\u00e9 magique mais on calcule, au fur et \u00e0 mesure de la lecture, les sommes sur chaque ligne/colonne/diagonales, tout en v\u00e9rifiant que tous les nombres sont dans le bon intervalle de valeur et qu'ils sont tous pr\u00e9sents. Une fois a lecture finie, il suffit de v\u00e9rifier que toutes les sommes sont \u00e9gales. #include <iostream> using namespace std ; const int MAX_TAILLE = 20 ; int direction [ 2 ][ MAX_TAILLE ]; // lignes + colonnes int diagonales [ 2 ]; int nombres [ MAX_TAILLE * MAX_TAILLE + 1 ]; int tailleGrille ; bool lireGrille () { int val ; for ( int ligne = 0 ; ligne < tailleGrille ; ligne ++ ) for ( int colonne = 0 ; colonne < tailleGrille ; colonne ++ ) { cin >> val ; if ( 1 <= val && val <= tailleGrille * tailleGrille && nombres [ val ] == 0 ) nombres [ val ] = 1 ; else return false ; direction [ 0 ][ ligne ] += val ; direction [ 1 ][ colonne ] += val ; if ( ligne == colonne ) diagonales [ 0 ] += val ; if ( ligne + colonne == tailleGrille - 1 ) diagonales [ 1 ] += val ; } return true ; } bool verifieValeurs () { const int val = diagonales [ 0 ]; for ( int dir = 0 ; dir <= 1 ; dir ++ ) for ( int i = 0 ; i < tailleGrille ; i ++ ) if ( direction [ dir ][ i ] != val ) return false ; return ( diagonales [ 0 ] == val ) && ( diagonales [ 1 ] == val ); } int main () { cin >> tailleGrille ; // Initilisation des tableaux : pas n\u00e9cessaire en pratique for ( int dir = 0 ; dir <= 1 ; dir ++ ) for ( int i = 0 ; i < tailleGrille ; i ++ ) direction [ dir ][ i ] = 0 ; for ( int i = 0 ; i <= 1 ; i ++ ) diagonales [ i ] = 0 ; for ( int i = 1 ; i <= tailleGrille * tailleGrille ; i ++ ) nombres [ i ] = 0 ; if ( lireGrille () && verifieValeurs ()) cout << \"yes\" << endl ; else cout << \"no\" << endl ; }","title":"Algorithme 2"},{"location":"Tableaux/Carr%C3%A9%20magique/","text":"Carr\u00e9 magique Algorithme 1 On commence par stocker le carr\u00e9 magique dans un tableau puis on calcule les sommes sur chaque ligne/colonne/diagonales et on v\u00e9rifie qu'elles sont toutes \u00e9gales. On doit \u00e9galement v\u00e9rifier que tous les nombres sont dans le bon intervalle de valeur et qu'ils sont tous pr\u00e9sents. tailleGrille <- LireEntier() nombresCarre <- Tableau 2D de taille tailleGrille * tailleGrille initialis\u00e9 avec des entiers lus Fonction tousNombresPresents() maxVal <- tailleGrille * tailleGrille + 1 presents <- Tableau de taille maxVal initialis\u00e9 \u00e0 Faux Pour chaque ligne dans nombresCarre faire Pour chaque nombre dans ligne faire Si (nombre <= 0) ou (nombre >= maxVal) ou presents[nombre] alors Retourne Faux sinon presents[nombre] <- Vrai Retourne Vrai Fonction totauxCorrects() Fonction totalPourDirection(linDepart, colDepart, deltaLin, deltaCol) lin <- linDepart col <- colDepart total <- 0 R\u00e9p\u00e9ter tailleGrille fois total <- total + nombresCarre[lin][col] lin <- lin + deltaLin col <- col + deltaCol Retourne total total <- totalPourDirection(0, 0, 1, 1) Si (totalPourDirection(0, tailleGrille - 1, 1, -1) != total) alors Retourne Faux Pour position <- 0 \u00e0 (tailleGrille - 1) faire Si totalPourDirection(position, 0, 0, 1) != total alors Retourne Faux Si totalPourDirection(0, position, 1, 0) != total alors Retourne Faux Retourne Vrai Si tousNombresPresents() et totauxCorrects() alors Afficher\u00c0LaLigne(\"yes\") sinon Afficher\u00c0LaLigne(\"no\") En python : def main (): def tousNombresPresents (): nonlocal tailleGrille maxVal = tailleGrille * tailleGrille + 1 presents = [ False ] * maxVal for ligne in nombresCarre : for nombre in ligne : if ( nombre <= 0 ) or ( nombre >= maxVal ) or presents [ nombre ]: return False else : presents [ nombre ] = True return True def totauxCorrects (): nonlocal tailleGrille def totalPourDirection ( linDepart , colDepart , deltaLin , deltaCol ): nonlocal tailleGrille lin , col = linDepart , colDepart total = 0 for loop in range ( tailleGrille ): total += nombresCarre [ lin ][ col ] lin += deltaLin col += deltaCol return total total = totalPourDirection ( 0 , 0 , 1 , 1 ) if ( totalPourDirection ( 0 , tailleGrille - 1 , 1 , - 1 ) != total ): return False for position in range ( tailleGrille ): if totalPourDirection ( position , 0 , 0 , 1 ) != total : return False if totalPourDirection ( 0 , position , 1 , 0 ) != total : return False return True tailleGrille = int ( input ()) nombresCarre = [ list ( map ( int , input () . split () )) for loop in range ( tailleGrille )] if tousNombresPresents () and totauxCorrects (): print ( \"yes\" ) else : print ( \"no\" ) main () En Java : import algorea.Scanner ; class Main { static int [][] nombresCarr\u00e9 ; static int tailleGrille ; public static void main ( String [] args ) { Scanner entr\u00e9e = new Scanner ( System . in ); tailleGrille = entr\u00e9e . nextInt (); nombresCarr\u00e9 = new int [ tailleGrille ][ tailleGrille ] ; for ( int ligne = 0 ; ligne < tailleGrille ; ligne ++ ) for ( int colonne = 0 ; colonne < tailleGrille ; colonne ++ ) nombresCarr\u00e9 [ ligne ][ colonne ] = entr\u00e9e . nextInt (); if ( tousNombresPr\u00e9sents () && totauxCorrects ()) System . out . println ( \"yes\" ); else System . out . println ( \"no\" ); } static int totalPourDirection ( int linDepart , int colDepart , int deltaLin , int deltaCol ) { int lin = linDepart , col = colDepart , total = 0 ; for ( int position = 0 ; position < tailleGrille ; position ++ ) { total += nombresCarr\u00e9 [ lin ][ col ] ; lin += deltaLin ; col += deltaCol ; } return total ; } static boolean totauxCorrects () { int total = totalPourDirection ( 0 , 0 , 1 , 1 ); if ( totalPourDirection ( 0 , tailleGrille - 1 , 1 , - 1 ) != total ) return false ; for ( int ligne = 0 ; ligne < tailleGrille ; ligne ++ ) if ( totalPourDirection ( ligne , 0 , 0 , 1 ) != total ) return false ; for ( int colonne = 0 ; colonne < tailleGrille ; colonne ++ ) if ( totalPourDirection ( 0 , colonne , 1 , 0 ) != total ) return false ; return true ; } static boolean tousNombresPr\u00e9sents () { int maxVal = tailleGrille * tailleGrille + 1 ; boolean [] pr\u00e9sents = new boolean [ maxVal ] ; for ( int nombre = 0 ; nombre < maxVal ; nombre ++ ) pr\u00e9sents [ nombre ] = false ; for ( int ligne = 0 ; ligne < tailleGrille ; ligne ++ ) for ( int colonne = 0 ; colonne < tailleGrille ; colonne ++ ) { int nombre = nombresCarr\u00e9 [ ligne ][ colonne ] ; if (( nombre <= 0 ) || ( nombre >= maxVal ) || pr\u00e9sents [ nombre ] ) return false ; pr\u00e9sents [ nombre ] = true ; } return true ; } } ``` c # include < stdio . h > # include < stdbool . h > # define MAX_TAILLE 20 int nombresCarre [ MAX_TAILLE ][ MAX_TAILLE ] ; int tailleGrille ; int totalPourDirection ( int linDepart , int colDepart , int deltaLin , int deltaCol ) { int lin = linDepart , col = colDepart , total = 0 ; for ( int position = 0 ; position < tailleGrille ; position ++ ) { total += nombresCarre [ lin ][ col ] ; lin += deltaLin ; col += deltaCol ; } return total ; } bool totauxCorrects () { int total = totalPourDirection ( 0 , 0 , 1 , 1 ); if ( totalPourDirection ( 0 , tailleGrille - 1 , 1 , - 1 ) != total ) return false ; for ( int ligne = 0 ; ligne < tailleGrille ; ligne ++ ) if ( totalPourDirection ( ligne , 0 , 0 , 1 ) != total ) return false ; for ( int colonne = 0 ; colonne < tailleGrille ; colonne ++ ) if ( totalPourDirection ( 0 , colonne , 1 , 0 ) != total ) return false ; return true ; } bool tousNombresPresents () { int maxVal = tailleGrille * tailleGrille + 1 ; int nombrePresent [ maxVal ] ; for ( int nombre = 0 ; nombre < maxVal ; nombre ++ ) nombrePresent [ nombre ] = 0 ; for ( int ligne = 0 ; ligne < tailleGrille ; ligne ++ ) for ( int colonne = 0 ; colonne < tailleGrille ; colonne ++ ) { int valeurCase = nombresCarre [ ligne ][ colonne ] ; if (( valeurCase <= 0 ) || ( valeurCase >= maxVal )) return 0 ; if ( nombrePresent [ valeurCase ] != 0 ) return 0 ; nombrePresent [ valeurCase ]++ ; } return 1 ; } int main () { scanf ( \"%d\" , & tailleGrille ); for ( int ligne = 0 ; ligne < tailleGrille ; ligne ++ ) for ( int colonne = 0 ; colonne < tailleGrille ; colonne ++ ) scanf ( \"%d\" , & ( nombresCarre [ ligne ][ colonne ] )); if ( tousNombresPresents () && totauxCorrects ()) printf ( \"yes\\n\" ); else printf ( \"no\\n\" ); return 0 ; } Algorithme 2 Dans cette variante on ne stocke pas le carr\u00e9 magique mais on calcule, au fur et \u00e0 mesure de la lecture, les sommes sur chaque ligne/colonne/diagonales, tout en v\u00e9rifiant que tous les nombres sont dans le bon intervalle de valeur et qu'ils sont tous pr\u00e9sents. Une fois a lecture finie, il suffit de v\u00e9rifier que toutes les sommes sont \u00e9gales. #include <iostream> using namespace std ; const int MAX_TAILLE = 20 ; int direction [ 2 ][ MAX_TAILLE ]; // lignes + colonnes int diagonales [ 2 ]; int nombres [ MAX_TAILLE * MAX_TAILLE + 1 ]; int tailleGrille ; bool lireGrille () { int val ; for ( int ligne = 0 ; ligne < tailleGrille ; ligne ++ ) for ( int colonne = 0 ; colonne < tailleGrille ; colonne ++ ) { cin >> val ; if ( 1 <= val && val <= tailleGrille * tailleGrille && nombres [ val ] == 0 ) nombres [ val ] = 1 ; else return false ; direction [ 0 ][ ligne ] += val ; direction [ 1 ][ colonne ] += val ; if ( ligne == colonne ) diagonales [ 0 ] += val ; if ( ligne + colonne == tailleGrille - 1 ) diagonales [ 1 ] += val ; } return true ; } bool verifieValeurs () { const int val = diagonales [ 0 ]; for ( int dir = 0 ; dir <= 1 ; dir ++ ) for ( int i = 0 ; i < tailleGrille ; i ++ ) if ( direction [ dir ][ i ] != val ) return false ; return ( diagonales [ 0 ] == val ) && ( diagonales [ 1 ] == val ); } int main () { cin >> tailleGrille ; // Initilisation des tableaux : pas n\u00e9cessaire en pratique for ( int dir = 0 ; dir <= 1 ; dir ++ ) for ( int i = 0 ; i < tailleGrille ; i ++ ) direction [ dir ][ i ] = 0 ; for ( int i = 0 ; i <= 1 ; i ++ ) diagonales [ i ] = 0 ; for ( int i = 1 ; i <= tailleGrille * tailleGrille ; i ++ ) nombres [ i ] = 0 ; if ( lireGrille () && verifieValeurs ()) cout << \"yes\" << endl ; else cout << \"no\" << endl ; }","title":"Carr\u00e9 magique"},{"location":"Tableaux/Carr%C3%A9%20magique/#carre-magique","text":"","title":"Carr\u00e9 magique"},{"location":"Tableaux/Carr%C3%A9%20magique/#algorithme-1","text":"On commence par stocker le carr\u00e9 magique dans un tableau puis on calcule les sommes sur chaque ligne/colonne/diagonales et on v\u00e9rifie qu'elles sont toutes \u00e9gales. On doit \u00e9galement v\u00e9rifier que tous les nombres sont dans le bon intervalle de valeur et qu'ils sont tous pr\u00e9sents. tailleGrille <- LireEntier() nombresCarre <- Tableau 2D de taille tailleGrille * tailleGrille initialis\u00e9 avec des entiers lus Fonction tousNombresPresents() maxVal <- tailleGrille * tailleGrille + 1 presents <- Tableau de taille maxVal initialis\u00e9 \u00e0 Faux Pour chaque ligne dans nombresCarre faire Pour chaque nombre dans ligne faire Si (nombre <= 0) ou (nombre >= maxVal) ou presents[nombre] alors Retourne Faux sinon presents[nombre] <- Vrai Retourne Vrai Fonction totauxCorrects() Fonction totalPourDirection(linDepart, colDepart, deltaLin, deltaCol) lin <- linDepart col <- colDepart total <- 0 R\u00e9p\u00e9ter tailleGrille fois total <- total + nombresCarre[lin][col] lin <- lin + deltaLin col <- col + deltaCol Retourne total total <- totalPourDirection(0, 0, 1, 1) Si (totalPourDirection(0, tailleGrille - 1, 1, -1) != total) alors Retourne Faux Pour position <- 0 \u00e0 (tailleGrille - 1) faire Si totalPourDirection(position, 0, 0, 1) != total alors Retourne Faux Si totalPourDirection(0, position, 1, 0) != total alors Retourne Faux Retourne Vrai Si tousNombresPresents() et totauxCorrects() alors Afficher\u00c0LaLigne(\"yes\") sinon Afficher\u00c0LaLigne(\"no\")","title":"Algorithme 1"},{"location":"Tableaux/Carr%C3%A9%20magique/#en-python","text":"def main (): def tousNombresPresents (): nonlocal tailleGrille maxVal = tailleGrille * tailleGrille + 1 presents = [ False ] * maxVal for ligne in nombresCarre : for nombre in ligne : if ( nombre <= 0 ) or ( nombre >= maxVal ) or presents [ nombre ]: return False else : presents [ nombre ] = True return True def totauxCorrects (): nonlocal tailleGrille def totalPourDirection ( linDepart , colDepart , deltaLin , deltaCol ): nonlocal tailleGrille lin , col = linDepart , colDepart total = 0 for loop in range ( tailleGrille ): total += nombresCarre [ lin ][ col ] lin += deltaLin col += deltaCol return total total = totalPourDirection ( 0 , 0 , 1 , 1 ) if ( totalPourDirection ( 0 , tailleGrille - 1 , 1 , - 1 ) != total ): return False for position in range ( tailleGrille ): if totalPourDirection ( position , 0 , 0 , 1 ) != total : return False if totalPourDirection ( 0 , position , 1 , 0 ) != total : return False return True tailleGrille = int ( input ()) nombresCarre = [ list ( map ( int , input () . split () )) for loop in range ( tailleGrille )] if tousNombresPresents () and totauxCorrects (): print ( \"yes\" ) else : print ( \"no\" ) main ()","title":"En python :"},{"location":"Tableaux/Carr%C3%A9%20magique/#en-java","text":"import algorea.Scanner ; class Main { static int [][] nombresCarr\u00e9 ; static int tailleGrille ; public static void main ( String [] args ) { Scanner entr\u00e9e = new Scanner ( System . in ); tailleGrille = entr\u00e9e . nextInt (); nombresCarr\u00e9 = new int [ tailleGrille ][ tailleGrille ] ; for ( int ligne = 0 ; ligne < tailleGrille ; ligne ++ ) for ( int colonne = 0 ; colonne < tailleGrille ; colonne ++ ) nombresCarr\u00e9 [ ligne ][ colonne ] = entr\u00e9e . nextInt (); if ( tousNombresPr\u00e9sents () && totauxCorrects ()) System . out . println ( \"yes\" ); else System . out . println ( \"no\" ); } static int totalPourDirection ( int linDepart , int colDepart , int deltaLin , int deltaCol ) { int lin = linDepart , col = colDepart , total = 0 ; for ( int position = 0 ; position < tailleGrille ; position ++ ) { total += nombresCarr\u00e9 [ lin ][ col ] ; lin += deltaLin ; col += deltaCol ; } return total ; } static boolean totauxCorrects () { int total = totalPourDirection ( 0 , 0 , 1 , 1 ); if ( totalPourDirection ( 0 , tailleGrille - 1 , 1 , - 1 ) != total ) return false ; for ( int ligne = 0 ; ligne < tailleGrille ; ligne ++ ) if ( totalPourDirection ( ligne , 0 , 0 , 1 ) != total ) return false ; for ( int colonne = 0 ; colonne < tailleGrille ; colonne ++ ) if ( totalPourDirection ( 0 , colonne , 1 , 0 ) != total ) return false ; return true ; } static boolean tousNombresPr\u00e9sents () { int maxVal = tailleGrille * tailleGrille + 1 ; boolean [] pr\u00e9sents = new boolean [ maxVal ] ; for ( int nombre = 0 ; nombre < maxVal ; nombre ++ ) pr\u00e9sents [ nombre ] = false ; for ( int ligne = 0 ; ligne < tailleGrille ; ligne ++ ) for ( int colonne = 0 ; colonne < tailleGrille ; colonne ++ ) { int nombre = nombresCarr\u00e9 [ ligne ][ colonne ] ; if (( nombre <= 0 ) || ( nombre >= maxVal ) || pr\u00e9sents [ nombre ] ) return false ; pr\u00e9sents [ nombre ] = true ; } return true ; } } ``` c # include < stdio . h > # include < stdbool . h > # define MAX_TAILLE 20 int nombresCarre [ MAX_TAILLE ][ MAX_TAILLE ] ; int tailleGrille ; int totalPourDirection ( int linDepart , int colDepart , int deltaLin , int deltaCol ) { int lin = linDepart , col = colDepart , total = 0 ; for ( int position = 0 ; position < tailleGrille ; position ++ ) { total += nombresCarre [ lin ][ col ] ; lin += deltaLin ; col += deltaCol ; } return total ; } bool totauxCorrects () { int total = totalPourDirection ( 0 , 0 , 1 , 1 ); if ( totalPourDirection ( 0 , tailleGrille - 1 , 1 , - 1 ) != total ) return false ; for ( int ligne = 0 ; ligne < tailleGrille ; ligne ++ ) if ( totalPourDirection ( ligne , 0 , 0 , 1 ) != total ) return false ; for ( int colonne = 0 ; colonne < tailleGrille ; colonne ++ ) if ( totalPourDirection ( 0 , colonne , 1 , 0 ) != total ) return false ; return true ; } bool tousNombresPresents () { int maxVal = tailleGrille * tailleGrille + 1 ; int nombrePresent [ maxVal ] ; for ( int nombre = 0 ; nombre < maxVal ; nombre ++ ) nombrePresent [ nombre ] = 0 ; for ( int ligne = 0 ; ligne < tailleGrille ; ligne ++ ) for ( int colonne = 0 ; colonne < tailleGrille ; colonne ++ ) { int valeurCase = nombresCarre [ ligne ][ colonne ] ; if (( valeurCase <= 0 ) || ( valeurCase >= maxVal )) return 0 ; if ( nombrePresent [ valeurCase ] != 0 ) return 0 ; nombrePresent [ valeurCase ]++ ; } return 1 ; } int main () { scanf ( \"%d\" , & tailleGrille ); for ( int ligne = 0 ; ligne < tailleGrille ; ligne ++ ) for ( int colonne = 0 ; colonne < tailleGrille ; colonne ++ ) scanf ( \"%d\" , & ( nombresCarre [ ligne ][ colonne ] )); if ( tousNombresPresents () && totauxCorrects ()) printf ( \"yes\\n\" ); else printf ( \"no\\n\" ); return 0 ; }","title":"En Java :"},{"location":"Tableaux/Carr%C3%A9%20magique/#algorithme-2","text":"Dans cette variante on ne stocke pas le carr\u00e9 magique mais on calcule, au fur et \u00e0 mesure de la lecture, les sommes sur chaque ligne/colonne/diagonales, tout en v\u00e9rifiant que tous les nombres sont dans le bon intervalle de valeur et qu'ils sont tous pr\u00e9sents. Une fois a lecture finie, il suffit de v\u00e9rifier que toutes les sommes sont \u00e9gales. #include <iostream> using namespace std ; const int MAX_TAILLE = 20 ; int direction [ 2 ][ MAX_TAILLE ]; // lignes + colonnes int diagonales [ 2 ]; int nombres [ MAX_TAILLE * MAX_TAILLE + 1 ]; int tailleGrille ; bool lireGrille () { int val ; for ( int ligne = 0 ; ligne < tailleGrille ; ligne ++ ) for ( int colonne = 0 ; colonne < tailleGrille ; colonne ++ ) { cin >> val ; if ( 1 <= val && val <= tailleGrille * tailleGrille && nombres [ val ] == 0 ) nombres [ val ] = 1 ; else return false ; direction [ 0 ][ ligne ] += val ; direction [ 1 ][ colonne ] += val ; if ( ligne == colonne ) diagonales [ 0 ] += val ; if ( ligne + colonne == tailleGrille - 1 ) diagonales [ 1 ] += val ; } return true ; } bool verifieValeurs () { const int val = diagonales [ 0 ]; for ( int dir = 0 ; dir <= 1 ; dir ++ ) for ( int i = 0 ; i < tailleGrille ; i ++ ) if ( direction [ dir ][ i ] != val ) return false ; return ( diagonales [ 0 ] == val ) && ( diagonales [ 1 ] == val ); } int main () { cin >> tailleGrille ; // Initilisation des tableaux : pas n\u00e9cessaire en pratique for ( int dir = 0 ; dir <= 1 ; dir ++ ) for ( int i = 0 ; i < tailleGrille ; i ++ ) direction [ dir ][ i ] = 0 ; for ( int i = 0 ; i <= 1 ; i ++ ) diagonales [ i ] = 0 ; for ( int i = 1 ; i <= tailleGrille * tailleGrille ; i ++ ) nombres [ i ] = 0 ; if ( lireGrille () && verifieValeurs ()) cout << \"yes\" << endl ; else cout << \"no\" << endl ; }","title":"Algorithme 2"}]}